# Study About Hash


## 해시(Hash)

- 산술적인 연산을 이용하여 키가 있는 위치를 계산하여 바로 찾아가는 방식
- 검색 효율 엄청 좋음 (O(1)임 ,즉 데이터의 수와 상관없이 검색효율이 겁나 좋다는 말임)
- 내부적으로 배열(Hash Table)을 사용하여 데이터 저장
- 데이터의 삽입과 삭제시 기존 데이터를 밀어내거나 채우는 작업이 필요 없도록 특별한 알고리즘을 이용하여 데이터와 연관된 고유의 숫자를 만들어 낸 뒤 이를 인덱스로 사용함 (연결 리스트의 단점 해결!)

------

## 해시 테이블(Hash Table)

- 해시 함수에 의해 계산된 주소 위치에 항목을 저장한 표
- n개의 버킷과 m개의 슬롯으로 구성
- 해시 테이블의 크기에 따라 해시의 성능 차이가 남
-----

## 해시 함수(Hash function/method)

 - 키 값을 해시주소(버킷주소)로 변환하는 함수
 - 해시 함수를 통해 할당되는 해시주소들은 숫자적으로 의미가 있는것은 아님
 - 해시 함수는 0~1사이의 버킷주소만 만들어야함   
 - Hash Method에 의해 반환된 데이터 고유의 숫자 값을 Hash Code 라고 함
   - Java 에서는 `Object 클래스의 hashCode()` 라는 메소드를 이용하여 모든 객체의 Hash Code를 쉽게 구할 수 있음.
- 좋은 해시 함수의 조건 :
   - 계산이 쉬어야함(검색 효울성이 좋다는 특징 때문에)
   - 충돌이 적어야함
   - 해시테이블에 고르게 분포 할 수 있도록 주소를 만들어야 함
### 해시 함수의 종류  

1. **중간 제곱 함수**

   - 키 값을 제곱한 결과값에서 중간에 있는 적당한 비트 수를 주소로 사용
   - 주소로 사용하는 비트의 수는 해시테이블의 버킷 개수에 따라 결정 (버킷이 256개라면 0~255를 만들기 위한 최소 비트인 8비트 사용)
    <br>
2. **제산함수(Division function)**  
     - 키 값 k 를 해시테이블의 크기인 M으로 나눈 나머지를 해시 주소로 사용(`h(k)=k mode M`)
     - M으로 나눈 나머지의 값의 범위는 `0~(M-1)`이므로 해시 테이블의 인덱스로 사용이 가능
     - 해시 주소는 충돌이 발생하지 않고 고르게 분포하도록 생성 되어야 하기 때문에 해시 테이블의 크기는 `적당한 크기의 소수를 사용해야함 `
<br>
3. **승산함수**
    - 키값 k와 정해진 실수 α를 곱한 결과에서 소수점 이하 부분만을 테이블 크기 M과 곱한 그 정수 값을 버킷 주소로 사용
     <br>

4. **접지함수**
   - 키의 비트수가 해시 테이블의 인덱스 비트수보다 클 때 사용
   - 키값을 해시테이블의 인덱스의 비트수와 같은 크기르 분할 한 후 분할 된 부분을 모두 더하여 해시 주소를 만듬 <br>
   - 종류로는 이동 접지 함수, 경계 접지 함수 가 있으나 ~~~궁금해지면 더 알아보겠음 현재는 별로 안궁금함ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ.....귀찮은거 아니고~~~
   <br>
5. **숫자 분석 함수**
    - 키 값을 이루고 있는 각 자릿수의 분포를 분석하여 해시 주소로 사용함
      - EX) 학번 = 입학년도(4)+학과코드(2)+주/야(1)+번호(2)  ===> 주/야(1)+번호(2)를 이용하여 해시 주소로 사용<br> (학생들 마다 고유한 번호를 가지고 있기 때문에 구분하기 아주 좋음 ....!! 충돌이 일어 날 일이 없음용)
    <br>  
6. **진법 변환 함수**
    - 키 값이 10진수가 아닌 다른 진수 일 때, 10진수로 변환하고 해시 테이블 주소로 필요한 자릿수 만큼만 하위 자리의 수를 이용
    <br>
7. **비트 추출 함수**
     - 해시 테이블의 크기가 2의 k 승일때, 키 값을 이진비트로 놓고 임의의 위치에 있는 비트들을 추출하여 주소로 사용
     - 충돌 발생 가능성이 높음 ==> 테이블 일부에 주소가 몰리지 않도록 키값의 비트를 미리 분석하여 사용해야함

---
## 해싱 검색

   - 키 값에 대해 해시 함수를 계산하여 주소를 구하고, 구한 주소에 해당하는 해시 테이블로 바로 이동하여 찾는 항목이 있으면 검색 성공 없으면 실패임
   - 해시 함수로 알아낸 버킷에 키값이 저장된 슬롯이 여러개 있는 경우에는 `순차 검색을 하여 해당 슬롯을 검색 `
---

## 동거자 (Synonym)

- 서로 다른 키값을 가지지만 해시 함수에 의해 같은 버킷에 저장 된 값
- 해시테이블에서는 버킷 수를 줄이고 같은 버킷안에 슬롯을 여러개 두어 해시 함수로 만든 주소가 같은 키 값들을 같은 버킷에 저장함
 `해시 테이블이 무조건 크다고 좋은게 아님 (한쪽에 몰려버리면 낭비되는 부분이 발생하기 때문에)`

 ---

## 충돌 (codeollision)
- 키 값이 서로 다른데 해시 함수에 의해 주어진 버킷 주소가 같은 경우
   - 비어있는 슬롯에 동거자 관계로 키값 저장
   - 포화버킷상태(슬롯이 전부 다 차있음) 라면 오버플로우 발생
- 키값밀도 = 실제 사용중인 키값의 수 / 사용 가능한 키 값의 수
- 적재밀도 = 실제 사용중인 키 값의 수/해시테이블에 저장가능한 전체 키 값의 수(버킷 개수 x 슬롯 개수)
- `충돌을 해결 하는 것이 해시의 핵심 해핵!!!!!!!!!!!!ㅋㅋㅋㅋㅋㅋㅋ `
---
## 충돌(오버플로우) 해결 방법

1. **선형개방주소법(=선형 조사법)**
   - 충돌이 일어난 키 값은 다른 비어있는 버킷을 찾아 저장함
   - 하는 행색이 순차검색과 같음 (충돌이 발생 하였을때만!!평상시는 노노)
   <br>
2. **체이닝 (=분리 연결법)**
   - 해시 테이블의 구조를 변경하여 각 버킷에 하나 이상의 키 값을 저장 할 수 있는 방법
    - 버킷에 슬롯을 동적으로 삽입/삭제 하기 위해서 연결 리스트를 사용
    - 버킷 내에서 원하는 슬롯을 검색하려면 버킷의 연결리스트를 선형 검색함
    - 슬롯은 헤드 노드에 연결리스트 형태로 일어남
    - 연속적 충돌 방지 가능   
---

## 참고 자료
[개발이 하고 싶어요](http://hyeonstorage.tistory.com/265)
C로 배우는 쉬운 자료구조 개정 3판 (한빛 아카데미/이지영 지음)

---
## 마무으리

오랜만에 알고리즘을 풀라고 했더니 해시 관련 문제라고 했다.
근데 나는 해시가 뭔지 잘 몰랐다 무턱대고 문제를 푸는 것은 시간낭비라고 생각해서 해시에 대한 개념을 공부하고 java로 구현 해본후 hashCode 이용해야 겠다고 생각해서 해시를 공부해보았다. 이제 어느정도 알 것 같다 근데 구현은 모르겠다. 그래도 도전!!!!!!!!!!!!도전은 늘 새롭고 새로운것을 알아내는 것은 늘 짜릿해~~~~~~~~~~~~~이제 구현하러 가겠슴당ㅎㅎ
